<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Privacy API implementation for Student Performance Predictor.
 *
 * Implements metadata, context/user listing, export, and deletion for GDPR compliance.
 *
 * @package    block_studentperformancepredictor
 * @copyright  2023 Your Name <[Email]>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace block_studentperformancepredictor\privacy;

defined('MOODLE_INTERNAL') || die();

use core_privacy\local\metadata\collection;
use core_privacy\local\request\approved_contextlist;
use core_privacy\local\request\approved_userlist;
use core_privacy\local\request\contextlist;
use core_privacy\local\request\deletion_criteria;
use core_privacy\local\request\helper;
use core_privacy\local\request\userlist;
use core_privacy\local\request\writer;
use core_privacy\local\request\transform;
use context_course;
use context;
use const CONTEXT_COURSE;
use const SQL_PARAMS_NAMED;

/**
 * Privacy API implementation for the Student Performance Predictor plugin.
 *
 * All user data (predictions, suggestions) is orchestrated by PHP but generated by the Python backend.
 * This provider ensures GDPR compliance for all backend-driven data.
 *
 * @package    block_studentperformancepredictor
 * @copyright  2023 Your Name <[Email]>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class provider implements
    \core_privacy\local\metadata\provider,
    \core_privacy\local\request\plugin\provider,
    \core_privacy\local\request\core_userlist_provider {

    /**
     * Returns metadata about this plugin's privacy usage.
     *
     * All fields are orchestrated by PHP but generated by the Python backend.
     *
     * @param collection $collection The metadata collection to populate.
     * @return collection The updated metadata collection.
     */
    public static function get_metadata(collection $collection): collection {
        $collection->add_database_table(
            'block_spp_predictions',
            [
                'modelid' => 'privacy:metadata:block_spp_predictions:modelid',
                'courseid' => 'privacy:metadata:block_spp_predictions:courseid',
                'userid' => 'privacy:metadata:block_spp_predictions:userid',
                'passprob' => 'privacy:metadata:block_spp_predictions:passprob',
                'riskvalue' => 'privacy:metadata:block_spp_predictions:riskvalue',
                'predictiondata' => 'privacy:metadata:block_spp_predictions:predictiondata',
                'timecreated' => 'privacy:metadata:block_spp_predictions:timecreated',
                'timemodified' => 'privacy:metadata:block_spp_predictions:timemodified',
            ],
            'privacy:metadata:block_spp_predictions'
        );

        $collection->add_database_table(
            'block_spp_suggestions',
            [
                'predictionid' => 'privacy:metadata:block_spp_suggestions:predictionid',
                'courseid' => 'privacy:metadata:block_spp_suggestions:courseid',
                'userid' => 'privacy:metadata:block_spp_suggestions:userid',
                'cmid' => 'privacy:metadata:block_spp_suggestions:cmid',
                'resourcetype' => 'privacy:metadata:block_spp_suggestions:resourcetype',
                'resourceid' => 'privacy:metadata:block_spp_suggestions:resourceid',
                'priority' => 'privacy:metadata:block_spp_suggestions:priority',
                'reason' => 'privacy:metadata:block_spp_suggestions:reason',
                'timecreated' => 'privacy:metadata:block_spp_suggestions:timecreated',
                'viewed' => 'privacy:metadata:block_spp_suggestions:viewed',
                'completed' => 'privacy:metadata:block_spp_suggestions:completed',
            ],
            'privacy:metadata:block_spp_suggestions'
        );

        return $collection;
    }

    /**
     * Get the list of contexts that contain user information for the specified user.
     *
     * @param int $userid The user to search.
     * @return contextlist The contextlist containing the list of contexts used in this plugin.
     */
    public static function get_contexts_for_userid(int $userid): contextlist {
        $contextlist = new contextlist();

        // Add course contexts where the user has predictions or suggestions (all backend-driven).
        $sql = "
            SELECT DISTINCT ctx.id
            FROM {context} ctx
            JOIN {course} c ON c.id = ctx.instanceid AND ctx.contextlevel = :contextlevel
            JOIN {block_spp_predictions} p ON p.courseid = c.id
            WHERE p.userid = :userid
        ";
        $params = [
            'contextlevel' => CONTEXT_COURSE,
            'userid' => $userid
        ];
        $contextlist->add_from_sql($sql, $params);

        $sql = "
            SELECT DISTINCT ctx.id
            FROM {context} ctx
            JOIN {course} c ON c.id = ctx.instanceid AND ctx.contextlevel = :contextlevel
            JOIN {block_spp_suggestions} s ON s.courseid = c.id
            WHERE s.userid = :userid
        ";
        $contextlist->add_from_sql($sql, $params);

        return $contextlist;
    }

    /**
     * Get the list of users who have data within a context.
     *
     * @param userlist $userlist The userlist containing the list of users who have data in this context/plugin combination.
     */
    public static function get_users_in_context(userlist $userlist) {
        $context = $userlist->get_context();
        if (!$context instanceof \context_course) {
            return;
        }
        $params = [
            'courseid' => $context->instanceid,
        ];
        // Add users who have predictions or suggestions in this course (all backend-driven).
        $sql = "SELECT userid FROM {block_spp_predictions} WHERE courseid = :courseid";
        $userlist->add_from_sql('userid', $sql, $params);
        $sql = "SELECT userid FROM {block_spp_suggestions} WHERE courseid = :courseid";
        $userlist->add_from_sql('userid', $sql, $params);
    }

    /**
     * Export all user data for the specified user, in the specified contexts.
     *
     * @param approved_contextlist $contextlist The approved contexts to export information for.
     */
    public static function export_user_data(approved_contextlist $contextlist) {
        global $DB;
        if (empty($contextlist->count())) {
            return;
        }
        $user = $contextlist->get_user();
        foreach ($contextlist->get_contexts() as $context) {
            if (!$context instanceof \context_course) {
                continue;
            }
            $courseid = $context->instanceid;
            // Export predictions (all backend-driven).
            $predictions = $DB->get_records('block_spp_predictions', ['courseid' => $courseid, 'userid' => $user->id]);
            foreach ($predictions as $prediction) {
                $predictiondata = [
                    'passprob' => $prediction->passprob,
                    'riskvalue' => $prediction->riskvalue,
                    'predictiondata' => $prediction->predictiondata,
                    'timecreated' => transform::datetime($prediction->timecreated),
                    'timemodified' => transform::datetime($prediction->timemodified),
                ];
                writer::with_context($context)->export_data(
                    [\get_string('privacy:predictionpath', 'block_studentperformancepredictor', $prediction->id)],
                    (object) $predictiondata
                );
                // Export associated suggestions (all backend-driven).
                $suggestions = $DB->get_records('block_spp_suggestions', ['predictionid' => $prediction->id, 'userid' => $user->id]);
                foreach ($suggestions as $suggestion) {
                    $suggestiondata = [
                        'resourcetype' => $suggestion->resourcetype,
                        'priority' => $suggestion->priority,
                        'reason' => $suggestion->reason,
                        'timecreated' => transform::datetime($suggestion->timecreated),
                        'viewed' => $suggestion->viewed,
                        'completed' => $suggestion->completed,
                    ];
                    writer::with_context($context)->export_data(
                        [
                            \get_string('privacy:predictionpath', 'block_studentperformancepredictor', $prediction->id),
                            \get_string('privacy:suggestionpath', 'block_studentperformancepredictor', $suggestion->id)
                        ],
                        (object) $suggestiondata
                    );
                }
            }
        }
    }

    /**
     * Delete all data for all users in the specified context.
     *
     * @param \context $context The specific context to delete data for.
     */
    public static function delete_data_for_all_users_in_context(\context $context) {
        global $DB;
        if (!$context instanceof \context_course) {
            return;
        }
        $courseid = $context->instanceid;
        // Delete all suggestions for the course (all backend-driven).
        $DB->delete_records('block_spp_suggestions', ['courseid' => $courseid]);
        // Get all predictions for the course.
        $predictions = $DB->get_records('block_spp_predictions', ['courseid' => $courseid], '', 'id');
        if (!empty($predictions)) {
            // Delete all suggestions associated with these predictions (should already be covered by the above, but just in case).
            list($insql, $inparams) = $DB->get_in_or_equal(array_keys($predictions), SQL_PARAMS_NAMED);
            $DB->delete_records_select('block_spp_suggestions', "predictionid $insql", $inparams);
            // Now delete the predictions.
            $DB->delete_records('block_spp_predictions', ['courseid' => $courseid]);
        }
    }

    /**
     * Delete all user data for the specified user, in the specified contexts.
     *
     * @param approved_contextlist $contextlist The approved contexts and user information to delete information for.
     */
    public static function delete_data_for_user(approved_contextlist $contextlist) {
        global $DB;
        if (empty($contextlist->count())) {
            return;
        }
        $user = $contextlist->get_user();
        foreach ($contextlist->get_contexts() as $context) {
            if (!$context instanceof \context_course) {
                continue;
            }
            $courseid = $context->instanceid;
            // Delete suggestions for the user in this course (all backend-driven).
            $DB->delete_records('block_spp_suggestions', ['courseid' => $courseid, 'userid' => $user->id]);
            // Get predictions for the user in this course.
            $predictions = $DB->get_records('block_spp_predictions', ['courseid' => $courseid, 'userid' => $user->id], '', 'id');
            if (!empty($predictions)) {
                // Delete suggestions associated with these predictions (should already be covered by the above, but just in case).
                list($insql, $inparams) = $DB->get_in_or_equal(array_keys($predictions), SQL_PARAMS_NAMED);
                $DB->delete_records_select('block_spp_suggestions', "predictionid $insql", $inparams);
                // Now delete the predictions.
                $DB->delete_records('block_spp_predictions', ['courseid' => $courseid, 'userid' => $user->id]);
            }
        }
    }

    /**
     * Delete multiple users within a single context.
     *
     * @param approved_userlist $userlist The approved context and user information to delete information for.
     */
    public static function delete_data_for_users(approved_userlist $userlist) {
        global $DB;
        $context = $userlist->get_context();
        if (!$context instanceof \context_course) {
            return;
        }
        $courseid = $context->instanceid;
        $userids = $userlist->get_userids();
        if (empty($userids)) {
            return;
        }
        // Delete suggestions for these users in this course (all backend-driven).
        list($insql, $inparams) = $DB->get_in_or_equal($userids, SQL_PARAMS_NAMED);
        $inparams['courseid'] = $courseid;
        $DB->delete_records_select(
            'block_spp_suggestions',
            "courseid = :courseid AND userid $insql",
            $inparams
        );
        // Get predictions for these users in this course.
        $predictions = $DB->get_records_select(
            'block_spp_predictions',
            "courseid = :courseid AND userid $insql",
            $inparams,
            '',
            'id'
        );
        if (!empty($predictions)) {
            // Delete suggestions associated with these predictions (should already be covered by the above, but just in case).
            list($predinsql, $predinparams) = $DB->get_in_or_equal(array_keys($predictions), SQL_PARAMS_NAMED);
            $DB->delete_records_select('block_spp_suggestions', "predictionid $predinsql", $predinparams);
            // Now delete the predictions.
            $DB->delete_records_select(
                'block_spp_predictions',
                "courseid = :courseid AND userid $insql",
                $inparams
            );
        }
    }
}